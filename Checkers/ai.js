// Generated by Creer at 03:55PM on April 26, 2015 UTC, git hash: '2acbba9c4b682c4de68840c1ca9bec631e9c635f'
// This is where you build your AI for the Checkers game.
var Class = require("../utilities/class");
var BaseAI = require("../baseAI");

function shuffle(o){ //v1.0
	for(var j, x, i = o.length; i; j = Math.floor(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);
	return o;
};

/// @class AI: the AI functions for the Checkers game.
var AI = Class(BaseAI, {
	// this is the name you send to the server to play as.
	getName: function() {
		return "Checkers JavaScript Player";
	},

	// this is called once the game starts and your AI knows its playerID and game. You can initialize your AI here.
	gameInitialized: function() {
		// pass
	},

	// this is called when the game's state updates, so if you are tracking anything you can update it here.
	gameUpdated: function() {
		this.checkersMap = [];
		for(var x = 0; x < this.game.boardWidth; x++) {
			this.checkersMap[x] = [];
		}

		for(var i = 0; i < this.game.checkers.length; i++) {
			var checker = this.game.checkers[i];

			if(checker.id === undefined) {
				console.log(checker);
			}
			this.checkersMap[checker.x][checker.y] = checker;
		}
	},


	// this is called when the game closes (ends), you can clean up your data and dump files here if need be
	close: function(){
		// pass
	},


	//--- Response Functions: functions you must fill out to send data to the game server to actually play the game! --\\

	/// This is called every time the AI is asked to respond with a command during their turn
	// @return <Command> the Command you want to run on the server this turn from a game object's command functions. If you do not return your player's endTurn() then this runTurn function will be called again after the game state updates.
	runTurn: function() {
		var myCheckers = this.player.checkers.clone();
		var forceJump = false;

		if(this.game.checkerMoved) {
			if(this.game.checkerMovedJumped) { // then it is valid to move again
				forceJump = true;
				myCheckers = [ this.game.checkerMoved ];
			}
			else { // it moved but did not jump, so it can't move again
				return this.player.endTurn();
			}
		}

		shuffle(myCheckers);

		var yDirection = this.player.yDirection;

		for(var i = 0; i < myCheckers.length; i++) {
			var checker = myCheckers[i];

			var neighbors = [
				{x: checker.x + 1, y: checker.y + yDirection},
				{x: checker.x - 1, y: checker.y + yDirection}
			];

			if(checker.kinged) {
				neighbors.push({x: checker.x + 1, y: checker.y - yDirection});
				neighbors.push({x: checker.x - 1, y: checker.y - yDirection})
			}

			shuffle(neighbors);

			while(neighbors.length > 0) {
				var neighbor = neighbors.pop();

				if(neighbor.x >= this.game.boardWidth || neighbor.x < 0 || neighbor.y >= this.game.boardHeight || neighbor.y < 0) {
					continue; // because we can't use this neighor as it is out of bounds
				}

				if(forceJump) { // then we have to jump
					if(neighbor.jump) {// we can jump!
						return checker.move(neighbor.x, neighbor.y);
					}
				}
				else {
					var jumpingChecker = this.checkersMap[neighbor.x][neighbor.y]
					if(jumpingChecker) { // we have to jump it, so add the next tile over
						if(jumpingChecker.owner !== checker.owner) {
							if(!neighbor.jump) {
								var dx = neighbor.x - checker.x;
								var dy = neighbor.y - checker.y;
								
								neighbors.push({
									jump: true,
									x: neighbor.x + dx,
									y: neighbor.y + dy,
								});
							}
						}
					}
					else { // it's valid!
						return checker.move(neighbor.x, neighbor.y);
					}
				}
			}
		}

		// if we got here there's nothing to do...
		return this.player.endTurn();
	},
});

module.exports = AI;
