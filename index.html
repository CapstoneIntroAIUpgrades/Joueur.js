<!doctype html>
<html>
	<head>
		<title>Socket.IO chat</title>
		<style>
			* { margin: 0; padding: 0; box-sizing: border-box; }
			body { font: 13px Helvetica, Arial; }
			form { background: #000; padding: 3px; display: block; bottom: 0; width: 100%; }
			form input { border: 0; padding: 10px; width: 90%; margin-right: .5%; }
			form button { width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; }
			#jsonState {padding: 1em; background: #ddd;}
			#gameBoard {padding: 1em; background: #ccc;}
			table, th, td {border: 1px solid black;}
			td { 
				padding: 0.25em;
				width: 34px;
				height: 34px;
				vertical-align: middle;
				text-align: center;
			}
			.legend {background: #fff; color: #777;}
			.horizontal-legend {padding-bottom: 1em;}
			.vertical-legend {padding-right: 1em;}
			.valid {background: #D6AD33;}
			.invalid {background: #80681F;}
			.owner-0 { color: white; }
			.owner-1 { color: red; }

			#messages { list-style-type: none; margin: 0; padding: 0; }
			#messages li { padding: 5px 10px; }
			#messages li:nth-child(odd) { background: #eee; }
		</style>
	</head>
	<body>
		<form action="">
			<input id="m" autocomplete="off" /><button>Send</button>
		</form>
		<p>White is player 0, Red is player 1</p>
		<div id="gameBoard"></div>
		<pre id="jsonState"></pre>
		<ul id="messages"></ul>
		<script src="https://cdn.socket.io/socket.io-1.2.0.js"></script>
		<script src="http://code.jquery.com/jquery-1.11.1.js"></script>
		<script>
			var serverLocation = "//localhost:3000";
			var print = function() {
				var msg = "";
				for(var i = 0; i < arguments.length; i++) {
					msg += (arguments[i] + ", ");
				}

				$('#messages').append($('<li>').text(msg));
			};

			var socket = io.connect(serverLocation, {
				reconnect: false,
			});

			var send = function(event, msg) {
				print("SENDING: ", event, msg);
				socket.emit(event, msg);
			};

			var game = {};
			game.init = function(data) {
				this._serverConstants = data.constants;
			}

			game.setState = function(completeState) {
				this.state = completeState;
			};

			game.applyDeltaState = function(delta) {
				this.mergeDelta(this.state, delta);
				print("post delta: ", JSON.stringify(this.state));
			};

			game.mergeDelta = function(state, delta) {
				var deltaLength = delta[this._serverConstants.DELTA_ARRAY_LENGTH];

				if(deltaLength !== undefined) { // then this part in the state is an array
					delete delta[this._serverConstants.DELTA_ARRAY_LENGTH]; // we don't want to copy this key/value over to the state, it was just to signify it is an array
					console.log("this is an array...");
					while(state.length > deltaLength) { // pop elements off the array until the array is short enough. an increase in array size will be added below as arrays resize when keys larger are set
						console.log("popping state", state.length, "once to near", deltaLength);
						state.pop();
					}
				}

				for(var key in delta) {
					if(delta.hasOwnProperty(key)) {
						if(delta[key] === this._serverConstants.DELTA_REMOVED) {
							delete state[key];
						}
						else if(typeof(delta[key]) == "object" && typeof(state[key]) == "object") {
							this.mergeDelta(state[key], delta[key]);
						}
						else {
							state[key] = delta[key];
						}
					}
				}
			};

			function shuffle(o){ //v1.0
				for(var j, x, i = o.length; i; j = Math.floor(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);
				return o;
			};

			var ai = {};

			ai.init = function(data) {
				this.name = data.name;
				this.playerName = data.playerName;
				this.gameName = data.gameName;
				this.gameSession = data.gameSession;
				this._serverConstants = data.constants;
			};

			ai.start = function(startData) {
				this.playerID = startData.playerID;
			};

			ai.command = function(command, data) {
				data = data || {};
				for(var key in data) {
					var value = data[key];
					if(typeof(value) == "object") {
						data[key] = this._serverConstants.ID_PREFIX + value.id;
					}
				}

				data.command = command;

				send("command", JSON.stringify(data));
			};

			ai.makeCommand = function() {
				print("MY TURN TO SEND COMMANDS");

				var checkersMap = [];
				for(var x = 0; x < game.state.boardWidth; x++) {
					checkersMap[x] = [];
				}

				var myCheckers = [];
				var forcedChecker;
				for(var i = 0; i < game.state.checkers.length; i++) {
					var checker = game.state.checkers[i];

					if(game.state.checkerMovedID === checker.id) { // then we have to use that checker
						forcedChecker = checker;
					}
					
					if(checker.ownerID === this.playerID) {
						myCheckers.push(checker);
					}

					checkersMap[checker.x][checker.y] = checker;
				}

				if(forcedChecker) {
					if(game.state.checkerMovedJumped) { // then it is valid to move again
						myCheckers = [ forcedChecker ];
					}
					else { // it moved but did not jump, so it can't move again
						return ai.command("done");
					}
					
				}

				shuffle(myCheckers);

				var yDirection = this.playerID === 0 ? 1 : -1;

				for(var i = 0; i < myCheckers.length; i++) {
					var checker = myCheckers[i];

					var neighbors = [
						{x: checker.x + 1, y: checker.y + yDirection},
						{x: checker.x - 1, y: checker.y + yDirection}
					];

					if(checker.kinged) {
						neighbors.push({x: checker.x + 1, y: checker.y - yDirection});
						neighbors.push({x: checker.x - 1, y: checker.y - yDirection})
					}

					shuffle(neighbors);

					while(neighbors.length > 0) {
						var neighbor = neighbors.pop();

						if(neighbor.x >= game.state.boardWidth || neighbor.x < 0 || neighbor.y >= game.state.boardHeight || neighbor.y < 0) {
							continue; // because we can't use this neighor as it is out of bounds
						}

						if(forcedChecker) { // then we have to jump
							if(neighbor.jump) {// we can jump!
								return ai.command("move", {checker: checker, x: neighbor.x, y: neighbor.y});
							}
						}
						else {
							var jumpingChecker = checkersMap[neighbor.x][neighbor.y]
							if(jumpingChecker) { // we have to jump it, so add the next tile over
								if(jumpingChecker.ownerID !== checker.ownerID) {
									if(!neighbor.jump) {
										var dx = neighbor.x - checker.x;
										var dy = neighbor.y - checker.y;
										
										neighbors.push({
											jump: true,
											x: neighbor.x + dx,
											y: neighbor.y + dy,
										});
									}
								}
							}
							else { // it's valid!
								return ai.command("move", {checker: checker, x: neighbor.x, y: neighbor.y});
							}
						}
					}
				}

				// if we got here there's nothing to do...
				ai.command("done");
			};


			var tableCells = [];
			var initGameBoard = function(data) {
				var table = $("<table>").appendTo($("#gameBoard"));
				for(var y = 0; y < data.boardHeight + 1; y++) {
					var row = $("<tr>").appendTo(table);
					for(var x = 0; x < data.boardWidth + 1; x++) {
						tableCells[x] = tableCells[x] || [];
						var cell = $("<td>").appendTo(row);
						
						if(x > 0 && y > 0) {
							tableCells[x-1][y-1] = cell;
						}
						else if(x === 0 && y === 0) {
							cell.addClass("legend").html("&nbsp;");
						}
						else if(x === 0) {
							cell.addClass("vertical-legend legend").html(y-1);
						}
						else if(y == 0) {
							cell.addClass("horizontal-legend legend").html(x-1);
						}

						if(!cell.hasClass("legend")) {
							if((x + y)%2 == 1) {
								cell.addClass("valid");
							}
							else {
								cell.addClass("invalid");
							}
						}
					}
				}
			};

			var updateGameBoard = function(data) {
				data = game.state;
				$("#jsonState").html(JSON.stringify(data, null, "    "));
				if(!$("#gameBoard").html()) {
					initGameBoard(data);
				}

				var locations = [];
				for(var x = 0; x < data.boardWidth; x++) {
					locations[x] = [];
				}

				for(var i = 0; i < data.checkers.length; i++) {
					var checker = data.checkers[i];
					locations[checker.x][checker.y] = checker;
				}

				for(var x = 0; x < data.boardWidth; x++) {
					for(var y = 0; y < data.boardHeight; y++) {
						var cell = tableCells[x][y];
						var checker = locations[x][y];
						var val = "&nbsp;";
						if(checker) {
							if(checker.kinged) {
								val = "{" + checker.id + "}";
							}
							else {
								val = "(" + checker.id + ")";
							}
							cell.addClass("owner-" + checker.ownerID);
						}
						else {
							cell.removeClass("owner-0 owner-1");
						}

						cell.html(val);
					}
				}
			};



			var serverResponseFunctions = {
				connected: function(json){
					var data = JSON.parse(json);
					ai.init(data);
					game.init(data);
					print("successfully connected to the server " + serverLocation);
				},
				state: function(json) {
					var data = JSON.parse(json);
					game.setState(data);
					updateGameBoard();
				},
				delta: function(json) {
					game.applyDeltaState(JSON.parse(json));
					updateGameBoard();
				},
				start: function(json) {
					ai.start(JSON.parse(json));
				},
				awaiting: function() {
					print("SERVER IS AWATING ME, I AM " + ai.playerID);
					ai.makeCommand();
				},
				ignoring: function() {
					print("SERVER IS NOW IGNORING ME");
				},
				invalid: function() {
					print("SERVER IGNORED ME");
				},
				over: function() {
					print("SERVER IS OVER, disconnecting...");
					socket.disconnect();
				},
				gamelog: function(msg) {
					print("GOT THE GAMELOG", msg);
				},
			};

			for(var property in serverResponseFunctions) {
				(function(property) {
					socket.on(property, function(msg){
						print("RAW:", property, msg);
						serverResponseFunctions[property](msg);
					});
				})(property); // stupid fucking javascript changing property
			}

			socket.on("disconnect", function(msg) {
				socket.on("disconnect", function() {});
				socket.disconnect();
				print("disconnected from the server");
			});

			socket.on("connect", function(msg) {
				send("play", JSON.stringify({
					playerName: "Javascript Player " + Math.random(),
					gameName: "checkers",
					gameSession: "*",
				}));
			})

			$('form').submit(function(){
				send("command", $('#m').val());
				$('#m').val('');
				return false;
			});

			print("--START--");
		</script>
	</body>
</html>
